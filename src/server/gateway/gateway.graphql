# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

# meta data describing the account
type AccountMeta {
  # iotex address
  address: String!
  balance: String!
  nonce: Int!
  numActions: Int!
  pendingNonce: Int!
}

type Action {
  core: ActionCore!
  senderPubKey: Buffer!
  signature: Buffer!
}

type ActionCore {
  candidateRegister: CandidateRegister
  candidateUpdate: CandidateBasicInfo
  claimFromRewardingFund: ClaimFromRewardingFund
  createDeposit: CreateDeposit
  createPlumChain: CreatePlumChain
  depositToRewardingFund: DepositToRewardingFund
  execution: Execution
  gasLimit: BigNumber!
  gasPrice: String!
  grantReward: GrantReward
  nonce: BigNumber!
  plumChallengeExit: PlumChallengeExit
  plumCreateDeposit: PlumCreateDeposit
  plumFinalizeExit: PlumFinalizeExit
  plumPutBlock: PlumPutBlock
  plumResponseChallengeExit: PlumResponseChallengeExit
  plumSettleDeposit: PlumSettleDeposit
  plumStartExit: PlumStartExit
  plumTransfer: PlumTransfer
  putBlock: PutBlock
  putPollResult: PutPollResult
  settleDeposit: SettleDeposit
  stakeAddDeposit: StakeAddDeposit
  stakeChangeCandidate: StakeChangeCandidate
  stakeCreate: StakeCreate
  stakeRestake: StakeRestake
  stakeTransferOwnership: StakeTransferOwnership
  stakeUnstake: StakeReclaim
  stakeWithdraw: StakeReclaim
  startSubChain: StartSubChain
  stopSubChain: StopSubChain
  terminatePlumChain: TerminatePlumChain
  transfer: Transfer
  version: Int!
}

input ActionCoreInput {
  candidateRegister: CandidateRegisterInput
  candidateUpdate: CandidateBasicInfoInput
  claimFromRewardingFund: ClaimFromRewardingFundInput
  createDeposit: CreateDepositInput
  createPlumChain: CreatePlumChainInput
  depositToRewardingFund: DepositToRewardingFundInput
  execution: ExecutionInput
  gasLimit: BigNumber!
  gasPrice: String!
  grantReward: GrantRewardInput
  nonce: BigNumber!
  plumChallengeExit: PlumChallengeExitInput
  plumCreateDeposit: PlumCreateDepositInput
  plumFinalizeExit: PlumFinalizeExitInput
  plumPutBlock: PlumPutBlockInput
  plumResponseChallengeExit: PlumResponseChallengeExitInput
  plumSettleDeposit: PlumSettleDepositInput
  plumStartExit: PlumStartExitInput
  plumTransfer: PlumTransferInput
  putBlock: PutBlockInput
  putPollResult: PutPollResultInput
  settleDeposit: SettleDepositInput
  stakeAddDeposit: StakeAddDepositInput
  stakeChangeCandidate: StakeChangeCandidateInput
  stakeCreate: StakeCreateInput
  stakeRestake: StakeRestakeInput
  stakeTransferOwnership: StakeTransferOwnershipInput
  stakeUnstake: StakeReclaimInput
  stakeWithdraw: StakeReclaimInput
  startSubChain: StartSubChainInput
  stopSubChain: StopSubChainInput
  terminatePlumChain: TerminatePlumChainInput
  transfer: TransferInput
  version: Int!
}

type ActionInfo {
  actHash: String!
  action: Action!
  blkHash: String!
  timestamp: Timestamp!
}

input ActionInput {
  core: ActionCoreInput!
  senderPubKey: Buffer!
  signature: Buffer!
}

# The BigNumber scalar type represents numeric values with precision as in https://github.com/MikeMcl/bignumber.js/
scalar BigNumber

# Properties of an blockMeta
type BlockMeta {
  deltaStateDigest: String!
  hash: String!
  height: Int!
  numActions: Int!
  producerAddress: String!
  receiptRoot: String!
  timestamp: Timestamp!
  transferAmount: String!
  txRoot: String!
}

# Properties of a BlockProducerInfo
type BlockProducerInfo {
  # BlockProducerInfo active
  active: Boolean!

  # BlockProducerInfo address
  address: String!

  # BlockProducerInfo production
  production: Int!

  # BlockProducerInfo votes
  votes: String!
}

# JS Buffer or Uint8Array
scalar Buffer

type Candidate {
  address: String!
  pubKey: Buffer
  rewardAddress: String!
  votes: Buffer
}

type CandidateBasicInfo {
  name: String!
  operatorAddress: String!
  rewardAddress: String!
}

input CandidateBasicInfoInput {
  name: String!
  operatorAddress: String!
  rewardAddress: String!
}

input CandidateInput {
  address: String!
  pubKey: Buffer
  rewardAddress: String!
  votes: Buffer
}

type CandidateList {
  candidates: [Candidate!]!
}

input CandidateListInput {
  candidates: [CandidateInput!]!
}

type CandidateRegister {
  autoStake: Boolean!
  candidate: CandidateBasicInfo!
  ownerAddress: String!
  payload: Buffer!
  stakedAmount: String!
  stakedDuration: Int!
}

input CandidateRegisterInput {
  autoStake: Boolean!
  candidate: CandidateBasicInfoInput!
  ownerAddress: String!
  payload: Buffer!
  stakedAmount: String!
  stakedDuration: Int!
}

#
type ChainMeta {
  epoch: Epoch!
  height: String!

  #
  numActions: String!
  tps: String!
}

type ClaimFromRewardingFund {
  amount: String!
  data: Buffer!
}

input ClaimFromRewardingFundInput {
  amount: String!
  data: Buffer!
}

type CreateDeposit {
  amount: Buffer!
  chainID: Int!
  recipient: String!
}

input CreateDepositInput {
  amount: Buffer!
  chainID: Int!
  recipient: String!
}

type CreatePlumChain {
  TBD: Boolean
}

input CreatePlumChainInput {
  TBD: Boolean
}

type DepositToRewardingFund {
  amount: String!
  data: Buffer!
}

input DepositToRewardingFundInput {
  amount: String!
  data: Buffer!
}

type Epoch {
  gravityChainStartHeight: Int!
  height: Int!
  num: Int!
}

# Properties of a EstimateGasForActionResponse
type EstimateGasForActionResponse {
  gas: String!
}

type Execution {
  amount: String!
  contract: String!
  data: Buffer!
}

input ExecutionInput {
  amount: String!
  contract: String!
  data: Buffer!
}

type GetAccountResponse {
  accountMeta: AccountMeta!
}

input GetActionsByAddressRequest {
  # iotex address
  address: String!
  count: BigNumber!
  start: BigNumber!
}

input GetActionsByBlockRequest {
  blkHash: String!
  count: Int!
  start: Int!
}

input GetActionsByHashRequest {
  actionHash: String!
  checkPending: Boolean!
}

input GetActionsByIndexRequest {
  count: BigNumber!
  start: BigNumber!
}

type GetActionsResponse {
  actionInfo: [ActionInfo!]
}

input GetBlockMetasByHashRequest {
  blkHash: String!
}

input GetBlockMetasByIndexRequest {
  count: Int!
  start: Int!
}

type GetBlockMetasResponse {
  blkMetas: [BlockMeta!]!
}

# Properties of a GetEpochMetaResponse
type GetEpochMetaResponse {
  # GetEpochMetaResponse blockProducersInfo
  blockProducersInfo: [BlockProducerInfo!]!

  # GetEpochMetaResponse epochData
  epochData: Epoch!

  # GetEpochMetaResponse totalBlocks
  totalBlocks: Int!
}

type GetReceiptByActionResponse {
  receiptInfo: ReceiptInfo
}

type GetServerMetaResponse {
  serverMeta: ServerMeta!
}

type GrantReward {
  height: String!
  type: RewardType!
}

input GrantRewardInput {
  height: String!
  type: RewardType!
}

type Line {
  x: String!
  y: Float!
}

type LiquidityInfo {
  liquidity: String!
  liquidityChange: String!
  logo: String!
  name: String!
  price: String!
  priceChange: String!
  symbol: String!
}

# Properties of an Log
type Log {
  actHash: Buffer!
  blkHeight: Int!

  # iotex address
  contractAddress: String!
  data: Buffer!
  index: Int!
  topics: [Buffer!]!
}

# scalar type of map buffer
scalar Map

type MerkleRoot {
  name: String!
  value: Buffer!
}

input MerkleRootInput {
  name: String!
  value: Buffer!
}

type PlumChallengeExit {
  challengeTransfer: Buffer!
  challengeTransferBlockHeight: Int!
  challengeTransferBlockProof: Buffer!
  coinID: Int!
  subChainAddress: String!
}

input PlumChallengeExitInput {
  challengeTransfer: Buffer!
  challengeTransferBlockHeight: Int!
  challengeTransferBlockProof: Buffer!
  coinID: Int!
  subChainAddress: String!
}

type PlumCreateDeposit {
  amount: Buffer!
  recipient: String!
  subChainAddress: String!
}

input PlumCreateDepositInput {
  amount: Buffer!
  recipient: String!
  subChainAddress: String!
}

type PlumFinalizeExit {
  coinID: Int!
  subChainAddress: String!
}

input PlumFinalizeExitInput {
  coinID: Int!
  subChainAddress: String!
}

type PlumPutBlock {
  height: Int!
  roots: Map!
  subChainAddress: String!
}

input PlumPutBlockInput {
  height: Int!
  roots: Map!
  subChainAddress: String!
}

type PlumResponseChallengeExit {
  challengeTransfer: Buffer!
  coinID: Int!
  previousTransferBlockHeight: Int!
  responseTransfer: Buffer!
  responseTransferBlockProof: Buffer!
  subChainAddress: String!
}

input PlumResponseChallengeExitInput {
  challengeTransfer: Buffer!
  coinID: Int!
  previousTransferBlockHeight: Int!
  responseTransfer: Buffer!
  responseTransferBlockProof: Buffer!
  subChainAddress: String!
}

type PlumSettleDeposit {
  coinID: Int!
}

input PlumSettleDepositInput {
  coinID: Int!
}

type PlumStartExit {
  exitTransfer: Buffer!
  exitTransferBlockHeight: Int!
  exitTransferBlockProof: Buffer!
  previousTransfer: Buffer!
  previousTransferBlockHeight: Int!
  previousTransferBlockProof: Buffer!
  subChainAddress: String!
}

input PlumStartExitInput {
  exitTransfer: Buffer!
  exitTransferBlockHeight: Int!
  exitTransferBlockProof: Buffer!
  previousTransfer: Buffer!
  previousTransferBlockHeight: Int!
  previousTransferBlockProof: Buffer!
  subChainAddress: String!
}

type PlumTransfer {
  coinID: Int!
  denomination: Buffer!
  owner: String!
  recipient: String!
}

input PlumTransferInput {
  coinID: Int!
  denomination: Buffer!
  owner: String!
  recipient: String!
}

type PutBlock {
  height: Int!
  roots: [MerkleRoot!]!
  subChainAddress: String!
}

input PutBlockInput {
  height: Int!
  roots: [MerkleRootInput!]!
  subChainAddress: String!
}

type PutPollResult {
  candidates: CandidateList
  height: String!
}

input PutPollResultInput {
  candidates: CandidateListInput
  height: String!
}

type Query {
  # get chain metadata
  chainMeta: ChainMeta!

  # estimate gas for action
  estimateGasForAction(action: ActionInput!): EstimateGasForActionResponse!

  # get the address detail of an address
  getAccount(
    # iotex address
    address: String!
  ): GetAccountResponse!

  # get action(s) by:
  getActions(
    # address with start index and action count
    byAddr: GetActionsByAddressRequest
    byBlk: GetActionsByBlockRequest

    # action hash
    byHash: GetActionsByHashRequest

    # start index and action count
    byIndex: GetActionsByIndexRequest
  ): GetActionsResponse!

  # Fetch basic token info by token address
  getBasicTokenInfo(
    # action Hash
    tokenAddress: String!
  ): TokenBasicInfo!

  # get block metadata(s) by:
  getBlockMetas(
    # block hash
    byHash: GetBlockMetasByHashRequest

    # start index and block count
    byIndex: GetBlockMetasByIndexRequest
  ): GetBlockMetasResponse!

  # get epoch meta
  getEpochMeta(epochNumber: Int!): GetEpochMetaResponse!

  # get receipt by action Hash
  getReceiptByAction(
    # action Hash
    actionHash: String!
  ): GetReceiptByActionResponse!

  # get server meta data by:
  getServerMeta: GetServerMetaResponse!
  health: String!

  # Fetch liquidty info by tokenAddress list.
  liquidity(
    # action Hash
    tokenAddressList: [String!]!
  ): [LiquidityInfo!]!

  # read contract
  readContract(callerAddress: String!, execution: ExecutionInput!): ReadContractResponse!

  # read state
  readState(arguments: [Buffer!]!, height: String!, methodName: Buffer!, protocolID: Buffer!): ReadStateResponse!

  # sendAction
  sendAction(action: ActionInput!): SendActionResponse!

  # suggest gas price
  suggestGasPrice: SuggestGasPriceResponse!

  # Transtions Statis By Platform
  transationsStatisByPlatform: TransactionStatisByPlatform!

  # Transtions list
  transtions: [Transaction!]!

  # Fetch num of users
  transtionsStatisByPlatform24H: Txs24HPortion!

  # Fetch txs statis data in 7 days
  transtionsStatisByPlatformWeek: Txs24HWeek!

  # Fetch txs num data by type in this month and in lastday
  txNumByType: txNumByType!

  # Fetch num of users
  usersNum: UsersNum!

  # Fetch total num of witness
  witnness(
    # It is used to sort data by time
    type: String!
  ): Witnness!
}

type ReadContractResponse {
  data: String!
}

type ReadStateResponse {
  data: Buffer!
}

# Properties of an Receipt
type Receipt {
  actHash: Buffer!
  blkHeight: Int!
  contractAddress: String!
  gasConsumed: Int!
  logs: [Log!]
  status: ReceiptStatus!
}

type ReceiptInfo {
  blkHash: String!
  receipt: Receipt
}

enum ReceiptStatus {
  ErrCandidateAlreadyExist
  ErrCandidateConflict
  ErrCandidateNotExist
  ErrCodeStoreOutOfGas
  ErrContractAddressCollision
  ErrDepth
  ErrExecutionReverted
  ErrInvalidBucketIndex
  ErrInvalidBucketType
  ErrLoadAccount
  ErrMaxCodeSizeExceeded
  ErrNoCompatibleInterpreter
  ErrNotEnoughBalance
  ErrOutOfGas
  ErrReduceDurationBeforeMaturity
  ErrUnauthorizedOperator
  ErrUnknown
  ErrUnstakeBeforeMaturity
  ErrWithdrawBeforeMaturity
  ErrWithdrawBeforeUnstake
  ErrWriteProtection
  Failure
  Success
}

enum RewardType {
  BlockReward
  EpochReward
}

type SendActionResponse {
  actionHash: Boolean
}

# Server meta data
type ServerMeta {
  buildTime: String!
  gitStatus: String!
  goVersion: String!
  packageCommitID: String!
  packageVersion: String!
}

type SettleDeposit {
  amount: Buffer!
  index: Int!
  recipient: String!
}

input SettleDepositInput {
  amount: Buffer!
  index: Int!
  recipient: String!
}

type StakeAddDeposit {
  amount: String!
  bucketIndex: Int!
  payload: Buffer!
}

input StakeAddDepositInput {
  amount: String!
  bucketIndex: Int!
  payload: Buffer!
}

type StakeChangeCandidate {
  bucketIndex: Int!
  candidateName: String!
  payload: Buffer!
}

input StakeChangeCandidateInput {
  bucketIndex: Int!
  candidateName: String!
  payload: Buffer!
}

type StakeCreate {
  autoStake: Boolean!
  candidateName: String!
  payload: Buffer!
  stakedAmount: String!
  stakedDuration: Int!
}

input StakeCreateInput {
  autoStake: Boolean!
  candidateName: String!
  payload: Buffer!
  stakedAmount: String!
  stakedDuration: Int!
}

type StakeReclaim {
  bucketIndex: Int!
  payload: Buffer!
}

input StakeReclaimInput {
  bucketIndex: Int!
  payload: Buffer!
}

type StakeRestake {
  autoStake: Boolean!
  bucketIndex: Int!
  payload: Buffer!
  stakedDuration: Int!
}

input StakeRestakeInput {
  autoStake: Boolean!
  bucketIndex: Int!
  payload: Buffer!
  stakedDuration: Int!
}

type StakeTransferOwnership {
  bucketIndex: Int!
  payload: Buffer!
  voterAddress: String!
}

input StakeTransferOwnershipInput {
  bucketIndex: Int!
  payload: Buffer!
  voterAddress: String!
}

type StartSubChain {
  chainID: Int!
  operationDeposit: Buffer!
  parentHeightOffset: Int!
  securityDeposit: Buffer!
  startHeight: Int!
}

input StartSubChainInput {
  chainID: Int!
  operationDeposit: Buffer!
  parentHeightOffset: Int!
  securityDeposit: Buffer!
  startHeight: Int!
}

type StopSubChain {
  chainID: Int!
  stopHeight: Int!
  subChainAddress: String!
}

input StopSubChainInput {
  chainID: Int!
  stopHeight: Int!
  subChainAddress: String!
}

type SuggestGasPriceResponse {
  gasPrice: Int!
}

type TerminatePlumChain {
  subChainAddress: String!
}

input TerminatePlumChainInput {
  subChainAddress: String!
}

type Timestamp {
  nanos: Int!
  seconds: Int!
}

type TokenBasicInfo {
  contractAddress: String!
  decimals: BigNumber!
  name: String!
  symbol: String!
  tokenAddress: String!
  totalSupply: String!
}

type Transaction {
  acthash: String!
  amount: Float!
  blkHash: String!
  blkHeight: Int!
  contractAddress: String!
  from: String!
  platform: String!
  timestamp: Int!
  to: String!
  tokenAddress: String!
  type: String!
}

type TransactionStatisByPlatform {
  data: [TxPlatform!]!
  total: String!
}

type Transfer {
  amount: String!
  payload: Buffer!
  recipient: String!
}

input TransferInput {
  amount: String!
  payload: Buffer!
  recipient: String!
}

type Tx24HData {
  key: Int!
  platform: String!
  proportion: Float!
  txs: Int!
}

type TxPlatform {
  platform: String!
  txs: Int!
}

type TxWeekData {
  platform: String!
  x: String!
  y: Int!
}

type Txs24HPortion {
  data: [Tx24HData!]!
}

type Txs24HWeek {
  data: [TxWeekData!]!
}

type UsersNum {
  data: [UsersNumData!]!
  total: Int!
}

type UsersNumData {
  num: Float!
  platform: String!
}

type Witnness {
  data: [Line!]!
  total: Int!
  total24changed: String!
}

type txNumByType {
  data: [txNumByTypeData!]!
}

type txNumByTypeData {
  num: Int!
  time: String!
  type: String!
}
